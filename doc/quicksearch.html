<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Classes Classes Camera Entity Geom CodeTree Expression Scope Sentence Shader SymbolTree Variable VarType Obj SubSpace Namespaces NEngine geometry GLNSLCompiler Util Grammar Vartypes Physic × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespaces Classes Camera Entity Geom CodeTree Expression Scope Sentence Shader SymbolTree Variable VarType Obj SubSpace Namespaces NEngine geometry GLNSLCompiler Util Grammar Vartypes Physic × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Index NEngine.js # NEngine.js A n-dimensional, full featured graphical-physical engine for the web. ## Features: ### N-dimensional geometry library and N-dimensional physical library: It contains basic n-dimensional polyhedrals and a basic geometry collision library to use in the physical system. ### Extended shader language: To create the n-dimensional shaders, it features an extended version of the Opengl Shading language called OpenGl N Shading Language or NSL using a small transcompiler that extends OGSL datatypes like matrices and vectors into N. ### Easy N-dimensional design and shader creation with Space Hierarchies: To manipulate multiple data spaces, and allow the existence of 3d spaces interacting with 5d spaces and handle simultaneously the two types of physics to later connect them into the same space, and to also simplify the shader organization and creation in the rendering, organizes its data into a Space Hierarchy that represents in a graph like manner, the spaces involved and the transformations in between them. ### New possible universes: Space Hierarchies allows to represent non-linear transformations like Bézier curves or fractal mappings from, for example object space into world space that modify the rendering and the physics for the interacting objects in those spaces. Thats right!, you can now create 3D hipersphere curved spaces inside 4D universes and simulate outer space accelerated expansion, or put many of those 4D universes inside six dimension spaces, curved like 4D hiperplanes, to construct complex space systems on which lot of different and interesting things can happen. You imagine literally seeing your galactic army crossing the universe bending into another reality?, now you can. ### Really fast: For all of its capabilities it has a good performance, that can work very good also in a smartphone, thanks to NMath optimization system on which it compiles extremely optimized hardcoded math operations in the given dimension in real time. Anyway, i need support improving the data structures in physics system and overall engine design because i´m not an expert. ## How it works: It builds its optimized mathematical functions from NMath, and directly projects dimension 'n' into dimension 'm' (commonly m = 3) inside the vertex shader, using webgl. A port to other platforms, with other rendering power would be interesting, but always maintaining its web approach so currently i´m more interested in translate parts of it into something easy to translate into asm, like c. Currently uses a little bit of twgl to work. ## Usage: Version: 0.5.8.10 Author: Nicolás Narváez × Search results Close "},"NEngine.html":{"id":"NEngine.html","title":"Namespace: NEngine","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: NEngine NEngine Classes Camera Entity Obj SubSpace Namespaces geometry GLNSLCompiler Physic × Search results Close "},"NEngine.Camera.html":{"id":"NEngine.Camera.html","title":"Class: Camera","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Camera NEngine. Camera new Camera() Represents a camera. It has a position, rotation, and viewport transformation, it offers methods for easy input connection Properties: Name Type Description cfg Object configuration object used on construction dim Integer × Search results Close "},"NEngine.Entity.html":{"id":"NEngine.Entity.html","title":"Class: Entity","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Entity NEngine. Entity new Entity() Has minimal abstract object information position, rotation, meta-data, geometry, material, collision config. Its extremely useful to represent a dynamic object that can interact physically with its environment, can be pluged into physics spaces and have meta-data. Properties: Name Type Description dim Integer Dimensionality of Ent. geometry Geom The visual geometry for the entity material Material The material data for the shader collider Object Collision processing info (type of detection, geom, etc) phy Object Physical data, for physical processors (elasticity, mass, friction coeficient, etc) container SpaceNode The SpaceNode that holds this entity Methods set(type, opt) Requires that the entity is previously registered on a space node. Sets a physics type on the entity, using a module object, module name, or module enum. Checks whether the objects array in the entity container (a SpaceNode) has the needed object type array instantiated, and conects this entity to it so it will be processed by the processors of the given type. This way you can configure an entity to be of a given type and be processed by the processors that process that type in the SpaceTree Parameters: Name Type Description type PhysicModule | String | Integer The module that defines the type you want to set into this entity, it can be the module, its registered name, or its enum Integer in the PhysicModulesEnum opt Object The options passed to the convert function of the module. × Search results Close "},"NEngine.geometry.html":{"id":"NEngine.geometry.html","title":"Namespace: geometry","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: geometry NEngine. geometry All geometry stuff, geoms and utilitary functions Classes Geom Methods &lt;static&gt; axis{n}(options) an axis in n-d is just n orthogonal lines that intersec in the origin this one has a different colour for each line so you can use it as a guide You specify de dimension choosing the n letter: (axis3, axis4) TODO: extend to N Parameters: Name Type Description options Object cfg object Returns: axis finished geometry Type Geom &lt;static&gt; boundingBox(geom) configures Geom boundingBox data Parameters: Name Type Description geom Geom Returns: this @ Type Geom &lt;static&gt; boundingSphere(geom) sets value of boundingSphereRadius Parameters: Name Type Description geom Geom Returns: this Type Geom &lt;static&gt; clone(original) Creates a copy in memory of the geometry Parameters: Name Type Description original Geom Returns: copy Type Geom &lt;static&gt; concat(a, b, keep_geom) Creates new geom space and fills it with the geoms in the given order if an entity is passed, applies transformations before adding TODO: n geoms to one (optimize) Parameters: Name Type Argument Default Description a Geom first geom b Geom last geom keep_geom Boolean &lt;optional&gt; false if true, then the first geom will be modified and returned as the joined geom &lt;static&gt; forEach() String forEach for geometries, applies transformations if it recieves an entity &lt;static&gt; grid{n}(options) creates a grid geometry, a grid is understod as a 2 dimensional net, this time we extend it to n dimensions. Each axis repeats the grid onto it, perpendicular to all the others. You specify de dimension choosing the n letter: (grid3, grid4) TODO: extend to N Parameters: Name Type Description options Object cfg object Properties Name Type Description size Integer the subdivisions of the grid for each axis size_{component} Integer you can target specific components (x, y, z, w) to override options.size on it length Float the length of the grid on all axis length_{component} Float you can target specific components (x, y, z, w) to override options.length on it wire Boolean if generate wire or face data on data buffers Returns: grid finished geometry Type Geom &lt;static&gt; octahedron{n}(options, size) just the n-dimensional extension of the octahedron You specify de dimension choosing the n letter: (octahedron3, octahedron4) TODO: extend to N Parameters: Name Type Description options Object cfg object size Float its length, size Returns: octahedron finished geometry Type Geom &lt;static&gt; simplex{n}(options) creates a simplex, a simplex is the simplest regular polyhedra on a given dimension, resembles the triangle but in the given dimension. For n-d a simplex has n-1 vertex and many faces has (n-1)-d subsimplex (subcollections) that tesellate it (dont collide when filling it) You specify de dimension choosing the n letter: (simplex3, simplex4) TODO: extend to N Parameters: Name Type Description options Object cfg object Properties Name Type Description size Integer the size (length) of the simplex wire Boolean if generate wire or face data on data buffers Returns: simplex finished geometry Type Geom &lt;static&gt; twglize(Geom) Convierte una geometria desde el formato Geom a el de twgl para usarse con la libreria Parameters: Name Type Description Geom Geom La geometria a convertir Returns: La geometria transformada Type twglGeom × Search results Close "},"NEngine.geometry.Geom.html":{"id":"NEngine.geometry.Geom.html","title":"Class: Geom","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Geom NEngine.geometry. Geom new Geom() Represents a Geometry object, contains collision data, vertex, colours and faces lists, those are in a data dictionary so adding more data lists is easy (like uniform data) it also contains the buffers generated for the shader Al the data lists follow the webgl format for buffers, you can check the format in their documentation, but here is a small review: A 3D vertex list looks like this: [ v1_x, v1_y, v1_z, v2_x, v2_y, ... , vn_y, vn_z ] All elements being float type For colors, they correspond to the vertex they match: [v1_cr, v1_cg, v1_cb, [v1_ca] , v2_cr, .. , vn_cb, [vn_ca] ] v1_cr means vertex 1 colour red, as you can see, each color can have 3 or four components (colour alpha is optional), but anyway this is just shader dependant, better look at the webgl docs! The faces list and the edges list are the same, but their elements are Integers instead of Floats and they represent an index in the vertex data list, for example, a face list like this: [0, 2, 1] means a triangle that has the first vertex in it first edge, the third on its second and so on. TODO: prepare standard simplex array for n-dimensional tesselation (faces for n-dimensional objects have (n-1) dimensions) and a simple way to cut them in shader program or a similar mechanism Properties: Name Type Description data Object contains data lists of elements Properties Name Type Description vertex Array color Array edges Array faces Array buffers Object this contains the shader program buffers, one of the is generated for each data list dim Integer dimensionality of the geom boundingBoxMin Float normally, shortest vertex component boundingBoxMax Float normally largest vertex component boundingSphereRadius Float bigger distance to a vertex Methods concat(joining_geom) a shortcut to concat, like calling concat(this, ...) Parameters: Name Type Description joining_geom Geom the geom to join into this Returns: concat(this, ...) Type Geom twglize() shortcut to twglize(this) Returns: twglize(this) Type twglGeom × Search results Close "},"NEngine.GLNSLCompiler.html":{"id":"NEngine.GLNSLCompiler.html","title":"Namespace: GLNSLCompiler","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: GLNSLCompiler NEngine. GLNSLCompiler Contains all related to GLNSLCompiler classes, functions and utilities \\n \\n Using the compiler: \\n Just call &quot;compile(code, config)&quot;, extra information is on the function docs TODO: scope resolution, currently only non-creating scope sentences are translated, like non [ifs, fors, functions, etc] Classes CodeTree Expression Scope Sentence Shader Variable Namespaces Util Vartypes Methods &lt;static&gt; compile(src, cfg) Compiles src using cfg Parameters: Name Type Description src String Contains the raw GLSL code cfg Object Config container Returns: translated Type String × Search results Close "},"NEngine.GLNSLCompiler.CodeTree.html":{"id":"NEngine.GLNSLCompiler.CodeTree.html","title":"Class: CodeTree","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: CodeTree NEngine.GLNSLCompiler. CodeTree new CodeTree() Represents the code structure as a scope recursive tree that contains variables and sentences, it holds general tree data and objects, the recursive scope chain is implemented by the scope objects starting by the root &quot;this.rootScope&quot;, it also gives you interfaces to manipulate it, generate an interpretation (interpret()) of the source, translate it (translate()) semantically-structurally, and then write it down (write()). :TODO: implement SrcMap usage, to standarize code manipulation across different semantic-level objects Properties: Name Type Description src String the source code for this tree out String The translated output from the last usage rootScope Scope The root of the scope tree, scope objects contain most of the relevant data: variables, sentences, etc. sentences Array.&lt;Sentence&gt; The sentences in the whole codetree, they also are indexed in their respective scopes, thought sentence.scope.sentences Methods &lt;static&gt; interpret(src) create scope tree and fills with sentences, also maps each string to a symbols in the src mapping, referenced has &quot;string_number&quot; TODO: pass all transofgmrations to srcmap actions Parameters: Name Type Description src String The source code to interpret, this.src is default × Search results Close "},"NEngine.GLNSLCompiler.Expression.html":{"id":"NEngine.GLNSLCompiler.Expression.html","title":"Class: Expression","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Expression NEngine.GLNSLCompiler. Expression new Expression() a and b point to expresions (variable expression) and in Used to create recursive translable expressión trees operator == null this.a contains a variable (&quot;literal expression&quot;) if operator == 'function' then a points to function and b to parametters expressions × Search results Close "},"NEngine.GLNSLCompiler.Scope.html":{"id":"NEngine.GLNSLCompiler.Scope.html","title":"Class: Scope","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Scope NEngine.GLNSLCompiler. Scope new Scope() Represents a recursive Scope tree. The rootScope contains the cache of the temp variables used in intermediate operations (on translated code). This cache gets added to the begining during translation Properties: Name Type Description code_tree CodeTree On rootScope, points to container CodeTree rootScope Scope Root Scope of the tree src String Contained code, currently only root-scope has parent Scope Parent Scope childs Array.&lt;Scope&gt; Child Scopes range Array.&lt;Integer&gt; Start and end index of code in rootScope.src variables Object.&lt;String, Variable&gt; Dictionary object for scope variables variables Object.&lt;String, Variable&gt; scope variables generated on ask constructor functions, dim-dependant functions, etc sentences Array.&lt;Sentence&gt; Holds scope sentences cacheVariables Object.&lt;TypeCodeName, CacheData&gt; contains current new temp_variables for extended datatypes Properties Name Type Description typeCodeName Object A specific datatype cache Properties Name Type Description vars Array.&lt;Variable&gt; The cache variables history Array.&lt;Variable&gt; The cachevariables arranged by last used Methods &lt;static&gt; ensureTypeCache(variable) Ensures that a given type has its cache variables instantiated for operations upon it, this is useful only during translation and final code writting. Adds them to variables array (avoid colisions) and cacheVariables (inform cache creation) sentence array. This affects only rootScope (only a single copy of each typecache is necessary) cache variable names: ___GLNSL_cache_(typeCodeName)_(cacheindex) Parameters: Name Type Description variable Variable The variable to ensure cache, needs to have its qualifiers, and type_data set &lt;static&gt; getTypeCache(variable) Iterates over the cached variables to avoid dataloss on two-handed cache operations (they require 3 cache vars) Parameters: Name Type Description variable Variable Contains datatype description (precision+datatype) Returns: variable - The cache variable you needed Type Variable &lt;static&gt; getVariable(varname) Recursively in the scope tree searches the variable Parameters: Name Type Description varname String Target variable name Returns: Return null if it cant be find Type Variable &lt;static&gt; isRoot() If this scope is the scopeRoot or not Returns: isScopeRoot Type Boolean &lt;static&gt; setParent() Correctly sets the parentScope &lt;static&gt; unsetParent() Correctly unsets the parentScope × Search results Close "},"NEngine.GLNSLCompiler.Sentence.html":{"id":"NEngine.GLNSLCompiler.Sentence.html","title":"Class: Sentence","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Sentence NEngine.GLNSLCompiler. Sentence new Sentence(opts) represents a single glsl sentence has inf. about variables, post-translation, and source location every range is in global (rootScope) coordinates Parameters: Name Type Description opts Object The options object Properties Name Type Description src String scope Scope range Array.&lt;Integer&gt; number Integer type String thisScope Scope components Expression | Array.&lt;Expression&gt; Properties: Name Type Description src String Sentence code excluding semicolon scope Scope containing scope range Array.&lt;Integer&gt; the indexes that limit this.src inside source code number Integer the index of this sentence in the scope sentence list; type String declaration, expression (this has subtypes: f.call, operation, etc), null, etc null represents an instruction that doesnt needs translation or that does nothing at all thisScope Scope filled only on sentence-block containing sentences components Expression | Array.&lt;Expression&gt; expressions in variables declaration, sentences in flow modifiers variables Array.&lt;Variable&gt; The variables declarated Methods &lt;static&gt; interpret() fills the sentence information interpreting the sentence str components list, its type and type related cfg, recognizes the sentence type and configures it accordingly currently only types declaration, expression and null are implemented, expression sentences include assignation &lt;static&gt; needsTranslation() Tells you if this needs translation Returns: Type Boolean &lt;static&gt; translate() generates a valid GLSL sentence (or group of sentences) that mimics the functionality on this sentence and stores it in this.out as a str it works differently on each sentence type Returns: translated Type String × Search results Close "},"NEngine.GLNSLCompiler.Shader.html":{"id":"NEngine.GLNSLCompiler.Shader.html","title":"Class: Shader","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Shader NEngine.GLNSLCompiler. Shader new Shader() Properties: Name Type Description js_variables Object.&lt;varname, value&gt; A dictionary indicating the js variable values in glnsl js interpolation, they represent a state machine for computing the final shader projection × Search results Close "},"NEngine.GLNSLCompiler.Util.html":{"id":"NEngine.GLNSLCompiler.Util.html","title":"Namespace: Util","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: Util NEngine.GLNSLCompiler. Util General utilities, that could be rehusable outside this application, like glsl grammar dictionaries, or more atomic and agnostic transcompiling utils. Classes SymbolTree Namespaces Grammar × Search results Close "},"NEngine.GLNSLCompiler.Util.Grammar.html":{"id":"NEngine.GLNSLCompiler.Util.Grammar.html","title":"Namespace: Grammar","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: Grammar NEngine.GLNSLCompiler.Util. Grammar Contains glsl grammar definition, useful grammar lists × Search results Close "},"NEngine.GLNSLCompiler.Util.SymbolTree.html":{"id":"NEngine.GLNSLCompiler.Util.SymbolTree.html","title":"Class: SymbolTree","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: SymbolTree NEngine.GLNSLCompiler.Util. SymbolTree new SymbolTree(src) This was created in a moment of despair. Now i cant find a use to it... mmmm, maybe just a middle-level tool Helps handling source mapping, stripping, scaping, etc. Provides functions to translate on its context (subsections of it, etc) like interpolate. the level of source mapping it makes is low, doesnt create recursive SymbolTree trees, but does create symbols trees Parameters: Name Type Description src String - Properties: Name Type Description src String Initial src str symbols Object.&lt;Symbol_key, str&gt; Maps mapped source symbols into the src, each symbol contains the mapping into src from mapped Methods &lt;static&gt; interpolate() interpolates all the symbols in the str &lt;static&gt; root() rot tree accessor &lt;static&gt; strip() Takes the strings delimited by the delimiter off, into a mapping avoids scaped delimiters and transparently resolves nested expressions including them in each strip ( 'aaa(asd(ss)asd)l' =&gt; 'aaa&quot;symbolkey&quot;l' ), stripts every encounter &lt;static&gt; symbols() returns symbols found in str as a dictionary × Search results Close "},"NEngine.GLNSLCompiler.Variable.html":{"id":"NEngine.GLNSLCompiler.Variable.html","title":"Class: Variable","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Variable NEngine.GLNSLCompiler. Variable new Variable(opts) Represents a variable in a scope Parameters: Name Type Description opts Object The options object Properties Name Type Description sentence Sentence The sentence containing var declaration sentence_place Integer - scope Scope - type Stxring &quot;primitive&quot; or &quot;function&quot; qualifiers Array storage, precission, return value, etc value String - name String - Properties: Name Type Description sentence Sentence The sentence containing var declaration sentence_place Integer Place in the declaration sentence scope Scope Container Scope type String &quot;primitive&quot; or &quot;function&quot; type_data: Object object with more specific datatype data for primitives is on the format provided by Vartypes.types qualifiers Array array with datatype dependant data primitives: variable declaration qualifiers format: [invariant, storage, precision, typeCodeName] function: return and parameters variables format: [return, params [..]] value String Given value, if this is a literal variable (value variable) name String Variable name Methods &lt;static&gt; config() Sets it type_data &lt;static&gt; declare() registers to the variable dictionary in the scope Throws: Error if its identifier was already declared × Search results Close "},"NEngine.GLNSLCompiler.Vartypes.html":{"id":"NEngine.GLNSLCompiler.Vartypes.html","title":"Namespace: Vartypes","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: Vartypes NEngine.GLNSLCompiler. Vartypes Contains all operation-resolving code, dependand on the specific variable type Classes VarType × Search results Close "},"NEngine.GLNSLCompiler.Vartypes.VarType.html":{"id":"NEngine.GLNSLCompiler.Vartypes.VarType.html","title":"Class: VarType","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: VarType NEngine.GLNSLCompiler.Vartypes. VarType new VarType() Its prototype depends on the specific vartype Properties: Name Type Description operations Object Operation handler functions codename String A unique identifier for the vartype, calculated has precision + prim_type type RegExp The regexp that matches the type. × Search results Close "},"NEngine.Obj.html":{"id":"NEngine.Obj.html","title":"Class: Obj","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: Obj NEngine. Obj new Obj() An old implementation of Entity. If you have problems with camera control use this instead, but beware, the new Camera object will make all you do with this object useless. Deprecated: Yes × Search results Close "},"NEngine.Physic.html":{"id":"NEngine.Physic.html","title":"Namespace: Physic","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Namespace: Physic NEngine. Physic All physic related stuff, structures to index and optimize n-dimensional spaces with lots or hundreds of entities like space trees. It also holds the PhysicModules wich define diferent kinds of physic processors and physic types, and defines the SpaceGraph for easy space configuration (lots of TODO here) Space and SpaceNode implement an axis oriented topology cappable of optimize them for collisisions and interspace intersections. Space is the SpaceNode network container, and holds common configurations for every SpaceNode. SpaceNode is a recursive representation of a n-axis × Search results Close "},"NEngine.SubSpace.html":{"id":"NEngine.SubSpace.html","title":"Class: SubSpace","body":" DocStrap Namespaces NEngineNEngine.geometryNEngine.GLNSLCompilerNEngine.GLNSLCompiler.UtilNEngine.GLNSLCompiler.Util.GrammarNEngine.GLNSLCompiler.VartypesNEngine.Physic Classes NEngine.CameraNEngine.EntityNEngine.geometry.GeomNEngine.GLNSLCompiler.CodeTreeNEngine.GLNSLCompiler.ExpressionNEngine.GLNSLCompiler.ScopeNEngine.GLNSLCompiler.SentenceNEngine.GLNSLCompiler.ShaderNEngine.GLNSLCompiler.Util.SymbolTreeNEngine.GLNSLCompiler.VariableNEngine.GLNSLCompiler.Vartypes.VarTypeNEngine.ObjNEngine.SubSpace Class: SubSpace NEngine. SubSpace new SubSpace(cfg) represents minimal space data, used in defining entities or similar stuff, a rotation plus a translation, possible deprecated on the near future when processing efficiency gets more tested Parameters: Name Type Description cfg Object Properties Name Type Description dim Integer dimension of the subspace Properties: Name Type Description p Vector position, length = dim r Matrix rotation, length = dim*dim × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
